---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

testing
```{r}
# libraries needed for the package
devtools::load_all()
library(sf)
library(dplyr)
library(purrr)
library(furrr)
library(tidyr)
library(tidygraph)

# libraries to help with this particular analysis
#library(raster)
library(ggplot2)
library(ggraph)
library(profvis)
```
set seed for reproducability
```{r}
set.seed(1000)
```

## Single population demography

First we'll create two test populations of ten people each, one with random ages and the other with only 25 year olds.

```{r}
test_pop1 <- create_individuals(10, random = FALSE)
test_pop2 <- create_individuals(10, random = TRUE)
```

Then run a 1,000 year simulation from each of the two initial populations.
```{r}
nsim <- 700

demographic_sim <- reduce(1:nsim, ~population_dynamics(.x), .init = test_pop1)
```

Look at the results.

```{r, echo = FALSE}
ggplot(demographic_sim, aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  labs(title = paste('Age distribution after', nsim, 'years'), subtitle = 'Red line = average age') +
  theme_bw()
```

Now we can look at a food-limited population.

```{r}
demographic_sim2 <- reduce(1:nsim, ~population_dynamics(.x, food_ratio = 0.8), .init = test_pop1)
```

Reducing the food ratio from 1 to 0.8 increases infant mortality, resulting in an older and smaller population than without food limitation.

```{r, echo = FALSE}
ggplot(demographic_sim2, aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  labs(title = paste('Age distribution after', nsim, 'years'), subtitle = 'Red line = average age') +
  theme_bw()
```

```{r, eval = FALSE}
profvis(reduce(1:nsim, ~population_dynamics(.x, food_ratio = 1), .init = test_pop1))
```

# Single settlement dynamics

```{r}
test_pop3 <- create_households(3)

farming_sim <- accumulate(1:nsim, ~household_dynamics(.x), .init = test_pop3)
```


```{r}
farming_sim %>%
  bind_rows(.id = 'time') %>%
  group_by(time) %>%
  summarise(population = sum(occupants)) %>%
  ggplot(aes(as.numeric(time), population)) +
  geom_line()
```

And we can look at the age distribution of the population in a food limited environment.
```{r}
farming_sim %>%
  .[[nsim+1]] %>%
  unnest %>%
  ggplot(aes(age)) +
  geom_histogram()
```
```{r}
# next step is to tweak micro behavior so this is asymptotic rather than piecewise
farming_sim %>%
  bind_rows(.id = 'time') %>%
  group_by(time) %>%
  summarise(population = sum(occupants), land = sum(land)) %>%
  ggplot(aes(population, land)) +
  geom_line(alpha = .2) +
  geom_point(aes(color = as.numeric(time))) +
  scale_color_viridis_c() +
  theme_classic() +
  labs(title = 'Coevolution of population and cultivated area')
```


```{r, eval = FALSE}
profvis(accumulate(1:100, ~household_dynamics(.x), .init = test_pop3))
```

Let's repeat this 20 times.
```{r, chache = TRUE}
nsim <- 500
plan(multicore)
farming_sim2 <- 1:50 %>%
  future_map(~ accumulate(1:nsim, ~household_dynamics(.x), .init = test_pop3)) %>%
  map_dfr(~bind_rows(., .id = 'time'), .id = 'rep') %>%
  mutate(time = as.numeric(time)) 
```

```{r}
farming_sim2 %>%
  group_by(rep, time) %>%
  summarise(population = sum(occupants)) %>%
  ggplot(aes(time, population)) +
  geom_line(aes(group = rep), alpha = 0.3) +
  geom_smooth() +
  theme_classic()
```

We can see from above that, in spite of the stochasticity, we converging on logistic growth. The inflection point above is at about year 250. We can replicate this using the discrete time logistic growth model with a carrying capacity of 150 and an intrinsic growth rate of 0.02, the typical value estimated for agrarian societies. Comparing our model's growth curve to the logistic equation shows our model has slightly slower growth, likely due to the extra stochasticity introduced by having discrete households rather than a single well-mixed population. In fact, a growth rate of ~1.8 fits better.
```{r}
logistic_growth <- accumulate(1:500, ~.x * (1 + 0.018 * (1 - (.x / 150))), .init = 9) %>%
  tibble(time = 0:500, population = .)

farming_sim2 %>%
  group_by(rep, time) %>%
  summarise(population = sum(occupants)) %>%
  ggplot(aes(time, population)) +
  geom_line(aes(group = rep), alpha = 0.3) +
  geom_smooth() +
  geom_line(data = logistic_growth, size = 1.2, color = 'red') +
  theme_classic()
```
```{r}
farming_sim2 %>%
  filter(rep == '1') %>%
  ggplot(aes(time, land, group = household)) +
  geom_line(alpha = 0.2) +
  theme_classic()

farming_sim2 %>%
  group_by(rep, time) %>%
  summarise(households = n()) %>%
  ggplot(aes(time, households)) +
  geom_line(aes(group = rep), alpha = 0.3) +
  geom_smooth() +
  theme_classic()

farming_sim2 %>%
  group_by(rep, time) %>%
  summarise(land = sum(land)) %>%
  ggplot(aes(time, land)) +
  geom_line(aes(group = rep), alpha = 0.3) +
  geom_smooth() +
  theme_classic()
```


First we'll look at the model behavior for just a single settlement, focusing on how equilibrium population density varies based on rainfall and other social and environmental factors.

Start by generating an experimental test population.

```{r, eval = FALSE}
test1 <- test %>%
  select(-data) %>%
  unnest %>%
  select(settlement, arable, precipitation, population) %>%
  full_join(environment) %>%
  mutate(population = if_else(is.na(population), 0, population))

test1 %>%
  filter(near(precipitation, 1)) %>%
  ggplot(aes(arable, population)) +
  geom_point() +
  geom_smooth(method = 'lm')

test1 %>%
  filter(near(arable, 1)) %>%
  ggplot(aes(precipitation, population)) +
  geom_point()

m1 <- mgcv::gam(population ~ s(precipitation) + s(arable), data = test1)
m2 <- mgcv::gam(population ~ te(precipitation, arable) , data = test1)

plot(m1)
plot(m2, scheme = 1)
AIC(m1,m2)
```
So from this we see a linear increase in equilibrium population with increase in arable land, and a nonlinear increase with precipitation. Nothing terribly surprising here.



should test to see if all the dplyr mutates and joins and whatever are faster or slower with more columns

```{r, eval = FALSE}
foodlim <- readr::read_csv('../../Foodlim_R_code/demog_vectors.csv')
```

This is where the default demographic data that comes with the package gets made. Need to improve.
```{r, eval = FALSE}
fertility_table <- tibble(
  age = 0:119,
  fertility_rate = c(rep(0, 12), 0.022, 0.022, 0.022, rep(c(0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134), each = 5), rep(0, 70))
)

mortality_table <- tibble(
  age = 0:119,
  mortality_rate = c(0.381, rep(0.063, 4), rep(c(0.013, 0.010, 0.013, 0.016, 0.018, 0.020, 0.022, 0.024, 0.025, 0.033, 0.042, 0.062, 
                                                 0.084, 0.122, 0.175, 0.254, 0.376, 0.552, 0.816, 1, 1, 1, 1), each = 5)),
  survivor_shape = foodlim$mortparms
)

life_table <- left_join(fertility_table, mortality_table)
usethis::use_data(life_table, internal =  TRUE, overwrite = TRUE)
usethis::use_testthat()

plot(fertility_table)
```

# Settlement dynamics
```{r}
world <- create_world()
ggplot(world) +
  geom_sf(aes(fill = arable), color = 'white') +
  coord_sf(datum = NA) +
  scale_fill_viridis_c() +
  theme_void()
```
  
```{r}
settlements <- create_settlements(world)

settlements %E>%
  mutate(route = near(distance, min(distance))) %>%
  filter(route == TRUE) %>%
ggraph() +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_fixed() +
  theme_void()
```


```{r, cache = TRUE}
test_grid <- accumulate(1:500, ~settlement_dynamics(.x), .init = settlements)
```

so right now, attractiveness is size based. that means that once a settlement hits 0, no one will ever want to move there right? this is why at equilibrium the largest sites are only ~150 people. So we need two sets of migrations, local and larger. maybe the spatial interaction model with full pariwise connections is a big migration, and something else for the neighboring 6 cells. perhaps that move can be land based or something else, maybe the fussion fission group joining thing. hmmmm
```{r}
test_grid %>%
  .[[300]] %E>%
   filter(near(distance, min(distance))) %>%
  ggraph +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_equal() +
  theme_graph()

test_grid %>%
  .[[300]] %>%
  as_tibble %>%
  st_as_sf %>%
  ggplot() +
  geom_sf(aes(fill = population), color = 'white') +
  coord_sf(datum = NA) +
  scale_fill_viridis_c()
```

```{r}
test_grid %>%
  map_dfr(as_tibble, .id = 'time') %>%
  ggplot(aes(as.numeric(time), population, group = settlement, color = settlement)) +
  geom_smooth(alpha = .5) +
  theme_classic()

test_grid %>%
  map_dfr(as_tibble, .id = 'time') %>%
  ggplot(aes(as.numeric(time), population, group = settlement, color = settlement)) +
  geom_line(alpha = .5) +
  theme_classic()

test_grid %>%
  map_dfr(as_tibble, .id = 'time') %>%
  mutate(land = map_dbl(households, ~sum(.$land))) %>%
  ggplot(aes(as.numeric(time), land, group = settlement, color = settlement)) +
  geom_smooth(alpha = .5) +
  theme_classic()
```


AT some point it'd be nice to include like 10-20 percent of your food ratio, etc, as a function of the flows from other places. or maybe the flows from other places make up a pool of resources at the settlement level that the households divide amongst themselves



sublinear scaling of area to population in a settlement
plot population vs urban area. so the maximum settlement we can hold in 1km has 25,000 people. beyond that we need more than one 1km tile
```{r}
tibble(population = seq(1,100000, 1000),
       area = 0.175 * population ^ 0.634) %>%
  ggplot(aes(population, area)) +
  geom_line()
```

# real world

```{r}
library(raster)
bbox <- extent(8.5, 11.5, 36, 37.5)#extent(5, 11.5, 34, 37.5)
bbox <- extent(450459.3, 729459.3, 3979550, 4157882)
prec <- raster('../North-Africa/data/annual_prec.tif') %>% 
  `/`(1000) %>%
  projectRaster(crs = "+proj=utm +zone=32 +north +ellps=WGS84 +datum=WGS84 +units=m") %>%
    crop(bbox)

boundary <- (!prec) %>% 
  rasterToPolygons(dissolve = TRUE) %>% 
  st_as_sf %>%
  st_cast('POLYGON') %>%
  mutate(area = st_area(geometry)) %>%
  filter(area == max(area))

slope <- raster('../North-Africa/data/topography/earthenv_90m.tif') %>%
  projectRaster(crs = "+proj=utm +zone=32 +north +ellps=WGS84 +datum=WGS84 +units=m") %>%
    crop(bbox) %>%
  mask(as(boundary, 'Spatial')) %>%
  terrain(opt = 'slope', unit = 'degrees')

hex <- boundary %>%
  st_make_grid(cellsize = 10000, square = FALSE) %>%
  st_sf %>%
  mutate(prec = raster::extract(prec, ., fun = mean, na.rm = TRUE),
         area = as.numeric(st_area(geometry)) * 1e-6, # convert from m2 to km2
         arable = raster::extract(slope <= 5, ., fun = sum, na.rm = TRUE) / 
           raster::extract(setValues(slope, 1), ., fun = sum, na.rm = TRUE),
         cultivable_area = area * arable) %>%
  filter(cultivable_area > 0)

ggplot(hex) +
  geom_sf(aes(fill = prec), color = 'white') +
  scale_fill_distiller(palette = 'YlGnBu', direction = 1) +
  coord_sf(datum = NA) +
  theme_void()

ggplot(hex) +
  geom_sf(aes(fill = cultivable_area), color = 'white') +
  scale_fill_viridis_c() +
  coord_sf(datum = NA) +
  theme_void()

hex %>%
  filter(cultivable_area < 1)
  arrange(cultivable_area)
```

```{r}
hyde <- raster('../North-Africa/cropland200AD.asc') %>%
  `crs<-`(value = '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0') %>%
    projectRaster(crs = "+proj=utm +zone=32 +north +ellps=WGS84 +datum=WGS84 +units=m") %>%
  crop(bbox)

plot(hyde)
```



```{r}
ariadne <- function(x){
  (1 + x ^ 4)^-1
}
tibble(distance = 1:100, 
       interaction = exp(-.1 * distance)) %>%
  ggplot(aes(distance, interaction)) +
  scale_y_continuous(limits = c(0,1)) +
  geom_line()
```

