---
title: "R Notebook"
output: html_notebook
---


testing
```{r}
devtools::load_all()
library(raster)
library(sf)
library(dplyr)
library(purrr)
library(furrr)
library(tidyr)
library(ggplot2)
library(tidygraph)
library(ggraph)
```

## Single population demography

First we'll create two test populations of ten people each, one with random ages and the other with only 25 year olds.

```{r}
set.seed(1000)
test_pop1 <- create_individuals(10, random = FALSE)
test_pop2 <- create_individuals(10, random = TRUE)
```

Then run a 1,000 year simulation from each of the two initial populations.
```{r}
nsim <- 600

demographic_sim <- reduce(1:nsim, ~population_dynamics(.x), .init = test_pop1)
```

Look at the results.

```{r, echo = FALSE}
ggplot(demographic_sim, aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  labs(title = 'Age distribution after 700 years', subtitle = 'Red line = average age') +
  theme_bw()
```

# Single settlement equilibria

First we'll look at the model behavior for just a single settlement, focusing on how equilibrium population density varies based on rainfall and other social and environmental factors.

Start by generating an experimental test population.

```{r}
environment <- crossing(arable = seq(0.3, 1, by = 0.05), precipitation = seq(0.3, 1, 0.05))
test_pop <- create_settlement(225, n_households = 4) %>%
  mutate(arable = environment$arable,
         precipitation = environment$precipitation,
         climatic_yield = calc_climatic_yield(precipitation))

test_pop
```



Now run the simulation for 500 years
```{r}
nsim <- 500
test <- reduce(1:nsim , ~household_dynamics(.x), .init = test_pop)

plan(multicore)
set.seed(1000)
test <- test_pop %>%
  mutate(chunk = rep(1:25, times = 9)) %>%
  group_by(chunk) %>%
  nest() %>%
  mutate(out = future_map(data, ~reduce(1:nsim , ~household_dynamics(.x), .init = .x), .progress = TRUE))
```

```{r}
test1 <- test %>%
  select(-data) %>%
  unnest %>%
  select(settlement, arable, precipitation, population) %>%
  full_join(environment) %>%
  mutate(population = if_else(is.na(population), 0, population))

test1 %>%
  filter(near(precipitation, 1)) %>%
  ggplot(aes(arable, population)) +
  geom_point() +
  geom_smooth(method = 'lm')

test1 %>%
  filter(near(arable, 1)) %>%
  ggplot(aes(precipitation, population)) +
  geom_point()

m1 <- mgcv::gam(population ~ s(precipitation) + s(arable), data = test1)
m2 <- mgcv::gam(population ~ te(precipitation, arable) , data = test1)

plot(m1)
plot(m2, scheme = 1)
AIC(m1,m2)
```
So from this we see a linear increase in equilibrium population with increase in arable land, and a nonlinear increase with precipitation. Nothing terribly surprising here.

```{r}
1:500 %>%
  reduce(~mutate(., households = map(households, ~reproduce(.) %>% die)), .init = test_pop) %>%
  unnest %>%
  unnest %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  theme_bw()
```

Now just run 1 settlement with 1 arable and precip, repeat several times, then end with the age distribution.
```{r}
test_pop2 <- create_settlement(1, n_household = 4)
library(profvis)
set.seed(1000)
test_time2 <- system.time(accumulate(1:600, ~household_dynamics(.x), .init = test_pop2))

set.seed(1000)
profvis(test4 <- accumulate(1:600, ~household_dynamics(.x), .init = test_pop2))

test3 <- 1:20 %>%
  future_map(~accumulate(1:600, ~household_dynamics(.x), .init = test_pop2), .progress = TRUE)

test3 %>%
  map_dfr(~bind_rows(., .id = 'time') %>% select(time, population), .id = 'rep') %>%
  ggplot(aes(as.numeric(time), population, group = rep)) +
  geom_line()
test3 %>%
  select(-data) %>%
  unnest %>%
  filter(arable == 1, precipitation == 1) %>%
  unnest %>%
  unnest %>%
  unnest %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 5, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  theme_bw()
```

should test to see if all the dplyr mutates and joins and whatever are faster or slower with more columns

```{r}
foodlim <- readr::read_csv('../../Foodlim_R_code/demog_vectors.csv')
```

This is where the default demographic data that comes with the package gets made. Need to improve.
```{r}
fertility_table <- tibble(
  age = 0:119,
  fertility_rate = c(rep(0, 12), 0.022, 0.022, 0.022, rep(c(0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134), each = 5), rep(0, 70))
)

mortality_table <- tibble(
  age = 0:119,
  mortality_rate = c(0.381, rep(0.063, 4), rep(c(0.013, 0.010, 0.013, 0.016, 0.018, 0.020, 0.022, 0.024, 0.025, 0.033, 0.042, 0.062, 0.084, 0.122, 0.175, 0.254, 0.376, 0.552, 0.816, 1, 1, 1, 1), each = 5)),
  survivor_shape = foodlim$mortparms
)


usethis::use_data(fertility_table, mortality_table, internal =  TRUE, overwrite = TRUE)
usethis::use_testthat()

plot(fertility_table)
```


```{r}


hex <- rbind(c(0,0), c(100,0), c(100,100), c(0,100), c(0,0)) %>%
  list %>%
  st_polygon %>%
  st_sfc %>%
  st_make_grid(square = FALSE)

pts <- st_centroid(hex)

# dist <- st_intersects(hex, sparse = TRUE) %>% 
#   as_tibble %>%
#   rename(from = row.id, to = col.id) %>%
#   mutate(distance = st_distance(pts[from], pts[2], by_element = TRUE))

dist <- st_distance(pts) %>%
  `rownames<-`(1:length(pts)) %>%
  `colnames<-`(1:length(pts))

dist_edgelist <- list(
  from = rownames(dist)[row(dist)] %||% row(dist),
  to = colnames(dist)[col(dist)] %||% col(dist),
  weight = dist
  ) %>% 
  map_dfc(as.vector) %>%
  mutate_if(is.character, as.integer)
  

#filter(near(weight, 10))

settlements <- create_settlement(length(hex)) %>%
  mutate(population = 10,
         x = st_coordinates(pts)[,1],
         y = st_coordinates(pts)[,2],
         geometry = pts) %>%
  tbl_graph(edges = dist_edgelist, directed = TRUE) %E>%
  rename(distance = weight)

settlements  

ggraph(settlements) +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_fixed() +
  theme_void()

settlements %N>%
  mutate(edge = centrality_degree() < 6)

# full <- igraph::distances(settlements, mode = 'out') %>%
#   as_tbl_graph %>%
#   mutate(settlement = 1:n()) %E>%
#   mutate(type = 'route')

# graph_join(settlements, full) %>%
#   filter(type == 'route') %>%
#   ggraph() +
#   geom_edge_link()
```

```{r}
settlements %E>%
  filter(near(weight, 10)) %>%
  ggraph() +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_equal() +
  theme_void()
```

```{r}
test <- settlements %N>%
  mutate(attractiveness = 10, pop_start = 10)


 reduce(1:100, ~interact2(.x), .init = test) %E>%
  filter(near(distance, 10)) %>%
  ggraph() +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_equal() +
  theme_void()
```

Now i need to go through each individual agent, select those who are of the right age, and see if they want to leave.


Move if migration prob true and food ratio less than 
```{r}
test %N>%
  interact %N>%
  as_tibble %>%
  select(-geometry) %>%
  unnest %>%
  unnest


rbernoulli(1, p = 0.2)
```



## land allocation, fissioning


```{r}
nsim <-70
test <- 1:nsim %>%
  accumulate(~population_dynamics(.x), .init = unnest(test_pop))


rm(households, check_fission, old_households, new_households)
fission <- function(households, fission_rate = 0.2){
  check_fission <- households %>%
    unnest %>%
    mutate(crowded = if_else(laborers > 5 & between(age, 15, 50), TRUE, FALSE),
           fission = rbernoulli(n(), p = ifelse(crowded, fission_rate, 0))) %>%
    group_by(settlement, household) %>%
    mutate(fissioners = sum(fission)) %>%
    ungroup
  
  old_households <- check_fission %>% 
    filter(fission == FALSE) %>%
    mutate(land = land - calc_land_need(fissioners, yield_memory))
  
  new_households <- check_fission %>% 
    filter(fission == TRUE)
  
  if(nrow(new_households) > 0){
    new_num <- old_households %>%
      pull(household) %>%
      new_hh_num(nrow(new_households))
    
    new_households <- new_households %>%
      mutate(household = new_num,
             land = calc_land_need(1, yield_memory),
             storage = 0)
    out <- bind_rows(old_households, new_households)
  } else {out <- old_households}

  out %>%
    select(-c(crowded, fission, fissioners)) %>%
    nest(age, .key = 'individuals')
}


test[[70]]  %>%
  fission %>% census
new_hh_num(3:5, 0)
#fissioning individuals leave household
  #mutate(land = land - calc_land_need(fissioners, yield_memory))
```

```{r}
mutate(household = pmap_chr(household, fission, fissioners, ~if_else(.2, new_hh_num(household, .3), .1)))
  nest(c(age, fission, crowded), .key = individuals) %>%
  group_by(settlement) %>%
  mutate(household = if_else(fission, new_hh_num(household), household))
  
test1 <- 2:5  %>%
  as.integer %>%
  max %>%
  `+`(1) %>%
  as.character() %>%
  c(test1, .)
test1 <- c(test1, new_num)

new_hh_num <- function(x, n){
  x %>%
    as.integer %>%
    max %>%
    `+`(1:n) %>%
    as.character
}


new_hh_num(2:6, 5)
test1

as.integer()
  as.numeric
  max(as.numeric(levels(.)))
  
tibble(test = list(factor(1:4), factor(5:10))) %>% unnest
```

count laborerers, if there are more than 5 people in a house, up to about 15, compare yourself to the most successful person in a random sampling of individuals in your settlement. If the settlement has 50 or fewer, just pick the best, if the settlement has more than 50 people than pick the best from a random sample of 50 people i the settlement.

but what to do once you've picked the model? use food ratio  or something else? or do you not even need to use a model, just have a random chance of fissioning once you're above 5 people? maybe try that to start, add in the more complicated fission fusion dynamics later

for each household
  if laborers > 5
    if rbernoulli .5 true
      change household number of one agent to a new number
      change that individual's land to land_Req for 1 person
      change original hoiuseholds land to land - fission land
      update laborers

So the problem is if we just add a new household id based on max current household id plus 1, then if that houshoeld dies another can take its place and it appears to be the same household
so maybe have the household id's be factors, that way the levels of the factor can be always preserved
yes! just take max(as.numeric(levels(household))) + 1
the problem is,all this nesting and unnesting will not preserve separate facotr levels for each settlement
```{r}
nsim <- 400
test <- 1:nsim %>%
  accumulate(~household_dynamics(.x), .init = test_pop)

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, occupants, group = interaction(household, settlement))) +
  geom_line(alpha = .3) +
  theme_classic()

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, food_ratio, group = interaction(household, settlement))) +
  geom_line(alpha = .3) +
  theme_classic()

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, land, group = interaction(household, settlement))) +
  geom_line(alpha = .3) +
  theme_classic()

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, storage, group = interaction(household, settlement))) +
  geom_line(alpha = .3) +
  theme_classic()

test[[nsim]] %>%
  unnest %>%
  unnest %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  theme_bw()
```

```{r}
test  %>% bind_rows(.id = 'time') %>%
  ggplot(aes(as.numeric(time), population, group = settlement)) +
           geom_line()

test %>% bind_rows(.id = 'time') %>%
  ggplot(aes(as.numeric(time), urban_area, group = settlement)) +
           geom_line()

test %>% map(~mutate(.,test = map_dbl(households, nrow))) %>%
  bind_rows(.id = 'time') %>%
  ggplot(aes(as.numeric(time), test, group = settlement)) +
           geom_line()
```

## migration module
```{r}
migration_prob <- 0.2

# source https://www.r-bloggers.com/round-values-while-preserve-their-rounded-sum-in-r/
# original https://biostatmatt.com/archives/2902
round_preserve_sum <- function(x, digits = 0) {
  up <- 10 ^ digits
  x <- x * up
  y <- floor(x)
  indices <- tail(order(x-y), round(sum(x)) - sum(y))
  y[indices] <- y[indices] + 1
  y / up
}

pts <- rbind(c(0,0), c(30,0), c(30,30), c(0,30), c(0,0)) %>%
  list %>%
  st_polygon %>%
  st_sfc %>%
  st_sample(4)

net <- tbl_graph(nodes = tibble(settlement = as.character(1:4), pts = pts),
          edges = expand.grid(from = 1:4, to = 1:4)) %E>%
  mutate(distance = st_distance(.N()$pts[from], .N()$pts[to], by_element = TRUE)) %>%
  filter(!edge_is_loop()) %>%
  activate('nodes')


dat <- test[[nsim]] %>%
  unnest %>%
  group_by(settlement) %>%
  mutate(migrant = if_else((food_ratio < mean(food_ratio) | food_ratio < 1) & 
                             rbernoulli(n(), migration_prob), TRUE, FALSE) &
                              laborers > 0) %>%
  ungroup %>%
  nest(household:last(everything()), .key = households) 

dat2 <- dat %>% mutate(households = map(households, ~filter(., migrant == FALSE) %>% 
                                          select(-migrant)))# migrants leave old settlement
dat3 <- dat %>%
  mutate(migrants = map(households, ~filter(., migrant == TRUE) %>%
                          select(-migrant) %>% 
                          mutate(household = NA, land = 0, storage = 0))) %>% 
  select(settlement, population, migrants) %>%
  left_join(net, ., by = 'settlement') %>%
  interact %E>%
  group_by(from) %>%
  mutate(migrants_from = .N()$migrants[from],
         n_mig = map_dbl(migrants_from, nrow),
         out_mig = round_preserve_sum(n_mig * flow / sum(flow))) %>%
  ungroup %>%
  arrange(from) %>%
  mutate(test = map2(migrants_from, out_mig, ~sample_n(.x, .y))) %>%
  as_tibble 
  

d4 <- dat3 %>%
  select(from, to, out_mig) %>%
  uncount(out_mig)

d5 <- dat3 %>% 
  pull(test) %>% 
  bind_rows

# no migrants
d6 <- select(dat2, settlement, households) # just households
d7 <- select(dat2, -households) # just settlements
d6 %>%
  unnest

  
bind_cols(d4, d5) %>%
  mutate(settlement = as.character(to)) %>%
    select(-c(from, to)) %>%
  bind_rows(unnest(d6), .) %>%
  arrange(settlement, household) %>%
  group_by(settlement) %>%
  mutate(n_households = mean(n_households, na.rm = TRUE), # hacky solution to propagate settlement information
         area = mean(area, na.rm = TRUE),
         arable = mean(arable, na.rm = TRUE),
         precipitation = mean(precipitation, na.rm = TRUE),
         runoff = mean(runoff, na.rm = TRUE),
         climatic_yield = mean(climatic_yield, na.rm = TRUE),
         population = mean(population, na.rm = TRUE),
         urban_area = mean(urban_area, na.rm = TRUE))

## an alternative idea for above script is to split the household and settlement tables, then rejoin at the end
```

the tricky issue is, once again, the problem with the household ids. I can't just add the new household id's after joining, because then it'd overwerite all the existing  ids

so maybe instead we need a master list of all Id's? no, there's still the problem of where to put that list and what to do with it. maybe an external vector of all the used ids, to be used as the levels for the household factor, and we keep that in the top level of the functions and use it for releveling the household ID vector whenever we need to

OR, have households be unique with respect to both settlement and household id. that's basically the current system ... and there's actually not really a big issue. but it does just kick the can of overlapping household ids down from the simulation level to the settlement level ... but its still a problem .... plus if we really did have universal ids for housheolds then they could move between settlements much more easily.

Ok, so its decided, we need a universal, simulation-wide collection of household IDs that we use to ensure no duplicate names. so we start by giving names to all the households, or ids at least, then building a vector in the household dynamics function that keeps track of all the names. so the question is what level of the functions to define this on, and what to do from there .... or maybe at the settlement level have the unique id's and use them as a nested data frame ... YES! thats it. ok glad we had this convo

```{r}
dat <- rerun(10, 1:nsim %>%
  accumulate(~household_dynamics(.x), .init = test_pop))

dat %>% map(~map(.,count_pop) %>% bind_rows(.id = 'time')) %>% bind_rows(.id = 'rep') %>%
  ggplot(aes(as.numeric(time), population, group = rep)) +
           geom_line(alpha = .5) +
  theme_bw()
```

```{r}
test[[nsim]] %>%
  mutate(population = map_dbl(households, ~pull(., occupants) %>% sum),
         urban_area = 0.175 * population ^ 0.634)
```

plot population vs urban area. so the maximum settlement we can hold in 1km has 25,000 people. beyond that we need more than one 1km tile
```{r}
tibble(population = seq(1,100000, 1000),
       area = 0.175 * population ^ 0.634) %>%
  ggplot(aes(population, area)) +
  geom_line()
```

## need a way to test if a settlement has become completely depopulated and allow it to repopulate
possible a reason to have the environental table be separate and repeatedly joined to the population table or something

```{r}
test_pop %>% 
  unnest() %>% 
  mutate(max_land = max_cultivable_land(laborers, farming_labor, area * arable * 100, type = 'unlimited'),
         land_need = pmin(max_land, calc_land_req(occupants, yield_memory)),# land in hectares to support the household, but no more than the laborer can work
         new_land = if_else(land_need > land, land_need - land, 0)) %>%
  group_by(settlement) %>%
  mutate(available_land = area * arable * 100 - sum(land),
         total_land_need = sum(new_land)) %>%
  ungroup %>%
  mutate(land = if_else(total_land_need > available_land, 
                        land + new_land / total_land_need * available_land, 
                        land + new_land)) %>%
  select(-c(land_need, max_land, new_land, total_land_need, available_land))
```

```{r}
plot(max_cultivable_land(5:10, 1, 100))
```


```{r}

```

