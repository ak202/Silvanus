---
title: "R Notebook"
output: html_notebook
---


testing
```{r}
#library(dplyr)
#library(purrr)
#library(magrittr)
#library(furrr)
devtools::load_all()
library(sf)
library(tidygraph)
library(dplyr)
library(purrr)
library(tidyr)
library(ggplot2)

library(ggraph)
library(raster)
```

```{r}
test_pop <- create_settlement(1)

1:500 %>%
  reduce(~mutate(., households = map(households, ~reproduce(.) %>% die)), .init = test_pop) %>%
  unnest %>%
  unnest %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  theme_bw()
```



```{r}
foodlim <- readr::read_csv('../../Foodlim_R_code/demog_vectors.csv')
```

```{r}
fertility_table <- tibble(
  age = 0:119,
  fertility_rate = c(rep(0, 12), 0.022, 0.022, 0.022, rep(c(0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134), each = 5), rep(0, 70))
)

mortality_table <- tibble(
  age = 0:119,
  mortality_rate = c(0.381, rep(0.063, 4), rep(c(0.013, 0.010, 0.013, 0.016, 0.018, 0.020, 0.022, 0.024, 0.025, 0.033, 0.042, 0.062, 0.084, 0.122, 0.175, 0.254, 0.376, 0.552, 0.816, 1, 1, 1, 1), each = 5))
)

survival_elasticity_table <- tibble(age = 0:119, survivor_shape = foodlim$mortparms)

usethis::use_data(fertility_table, mortality_table, survival_elasticity_table, internal = TRUE, overwrite = TRUE)
usethis::use_testthat()

plot(fertility_table)
```

```{r}
tibble(fertility_rate = test$m0 * 2) %>%
  mutate(age = 0:119) %>%
bind_rows(fertility_table, .id= 'type') %>%
ggplot(aes(age, fertility_rate, color = type)) +
  geom_point()


plot(pgamma((1:99)/100, shape = 4.579627, scale = .1))
```

```{r}
tibble(mortality_rate = 1 - foodlim$p0) %>%
  mutate(age = 0:119) %>%
bind_rows(mortality_table, .id= 'type') %>%
ggplot(aes(age, mortality_rate, color = type)) +
  geom_point()

plot(test$mortparms)

tibble(age = 0:119, survivor_shape = foodlim$mortparms)
foodlim$mortparms


plot(pgamma((1:99)/100, shape = foodlim$mortparms[1], scale = .1) * test$p0[1])
```



```{r}


hex <- rbind(c(0,0), c(100,0), c(100,100), c(0,100), c(0,0)) %>%
  list %>%
  st_polygon %>%
  st_sfc %>%
  st_make_grid(square = FALSE)

pts <- st_centroid(hex)

# dist <- st_intersects(hex, sparse = TRUE) %>% 
#   as_tibble %>%
#   rename(from = row.id, to = col.id) %>%
#   mutate(distance = st_distance(pts[from], pts[2], by_element = TRUE))

dist <- st_distance(pts) %>%
  `rownames<-`(1:length(pts)) %>%
  `colnames<-`(1:length(pts))

dist_edgelist <- list(
  from = rownames(dist)[row(dist)] %||% row(dist),
  to = colnames(dist)[col(dist)] %||% col(dist),
  weight = dist
  ) %>% 
  map_dfc(as.vector) %>%
  mutate_if(is.character, as.integer)
  

#filter(near(weight, 10))

settlements <- create_settlement(length(hex)) %>%
  mutate(population = 10,
         x = st_coordinates(pts)[,1],
         y = st_coordinates(pts)[,2],
         geometry = pts) %>%
  tbl_graph(edges = dist_edgelist, directed = TRUE) %E>%
  rename(distance = weight)

settlements  

ggraph(settlements) +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_fixed() +
  theme_void()

settlements %N>%
  mutate(edge = centrality_degree() < 6)

# full <- igraph::distances(settlements, mode = 'out') %>%
#   as_tbl_graph %>%
#   mutate(settlement = 1:n()) %E>%
#   mutate(type = 'route')

# graph_join(settlements, full) %>%
#   filter(type == 'route') %>%
#   ggraph() +
#   geom_edge_link()
```

```{r}
settlements %E>%
  filter(near(weight, 10)) %>%
  ggraph() +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_equal() +
  theme_void()
```

```{r}
test <- settlements %N>%
  mutate(attractiveness = 10, pop_start = 10)


 reduce(1:100, ~interact2(.x), .init = test) %E>%
  filter(near(distance, 10)) %>%
  ggraph() +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_equal() +
  theme_void()
```

Now i need to go through each individual agent, select those who are of the right age, and see if they want to leave.


Move if migration prob true and food ratio less than 
```{r}
test %N>%
  interact %N>%
  as_tibble %>%
  select(-geometry) %>%
  unnest %>%
  unnest


rbernoulli(1, p = 0.2)
```



## land allocation
```{r}
environment <- tibble(settlement = 1, area = 1, arable = 1, precipitation = 1, runoff = 0, climatic_yield = calc_climatic_yield(precipitation))

test_pop <- create_settlement(1, n_households = 4)
```

```{r}
nsim <-70
test <- 1:nsim %>%
  accumulate(~population_dynamics(.x), .init = unnest(test_pop))
rm(households, check_fission, old_households, new_households)
fission <- function(households, fission_rate = 0.2){
  check_fission <- households %>%
    unnest %>%
    mutate(crowded = if_else(laborers > 5 & between(age, 15, 50), TRUE, FALSE),
           fission = rbernoulli(n(), p = ifelse(crowded, fission_rate, 0))) %>%
    group_by(settlement, household) %>%
    mutate(fissioners = sum(fission)) %>%
    ungroup
  
  old_households <- check_fission %>% 
    filter(fission == FALSE) %>%
    mutate(land = land - calc_land_need(fissioners, yield_memory))
  
  new_households <- check_fission %>% 
    filter(fission == TRUE)
  
  if(nrow(new_households) > 0){
    new_num <- old_households %>%
      pull(household) %>%
      new_hh_num(nrow(new_households))
    
    new_households <- new_households %>%
      mutate(household = new_num,
             land = calc_land_need(1, yield_memory),
             storage = 0)
    out <- bind_rows(old_households, new_households)
  } else {out <- old_households}

  out %>%
    select(-c(crowded, fission, fissioners)) %>%
    nest(age, .key = 'individuals')
}


test[[70]]  %>%
  fission %>% census
new_hh_num(3:5, 0)
#fissioning individuals leave household
  #mutate(land = land - calc_land_need(fissioners, yield_memory))
```

```{r}
mutate(household = pmap_chr(household, fission, fissioners, ~if_else(.2, new_hh_num(household, .3), .1)))
  nest(c(age, fission, crowded), .key = individuals) %>%
  group_by(settlement) %>%
  mutate(household = if_else(fission, new_hh_num(household), household))
  
test1 <- 2:5  %>%
  as.integer %>%
  max %>%
  `+`(1) %>%
  as.character() %>%
  c(test1, .)
test1 <- c(test1, new_num)

new_hh_num <- function(x, n){
  x %>%
    as.integer %>%
    max %>%
    `+`(1:n) %>%
    as.character
}


new_hh_num(2:6, 5)
test1

as.integer()
  as.numeric
  max(as.numeric(levels(.)))
  
tibble(test = list(factor(1:4), factor(5:10))) %>% unnest
```

count laborerers, if there are more than 5 people in a house, up to about 15, compare yourself to the most successful person in a random sampling of individuals in your settlement. If the settlement has 50 or fewer, just pick the best, if the settlement has more than 50 people than pick the best from a random sample of 50 people i the settlement.

but what to do once you've picked the model? use food ratio  or something else? or do you not even need to use a model, just have a random chance of fissioning once you're above 5 people? maybe try that to start, add in the more complicated fission fusion dynamics later

for each household
  if laborers > 5
    if rbernoulli .5 true
      change household number of one agent to a new number
      change that individual's land to land_Req for 1 person
      change original hoiuseholds land to land - fission land
      update laborers

So the problem is if we just add a new housheold id based on max current household id plus 1, then if that houshoeld dies another can take its place and it appears to be the same household
so maybe have the household id's be factors, that way the levels of the factor can be always preserved
yes! just take max(as.numeric(levels(household))) + 1
the problem is,all this nesting and unnesting will not preserve separate facotr levels for each settlement
```{r}
test <- 1:1000 %>%
  accumulate(~household_dynamics(.x), .init = test_pop)

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, occupants, group = household)) +
  geom_line(alpha = .3) +
  theme_classic()

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, food_ratio, group = household)) +
  geom_line(alpha = .3) +
  theme_classic()

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, land, group = household)) +
  geom_line(alpha = .3) +
  theme_classic()

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, storage, group = household)) +
  geom_line(alpha = .3) +
  theme_classic()

test %>% bind_rows(.id = 'time') %>%
  unnest(households) %>%
  mutate(time = as.numeric(time)) %>%
  ggplot(aes(time, yield_memory, group = household)) +
  geom_line(alpha = .3) +
  theme_classic()

test[[500]] %>%
  unnest %>%
  unnest %>%
  ggplot(aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = mean(age)), color = 'red', linetype = 2) +
  theme_bw()


test[[1000]] %>% unnest %>% summarise(sum(land))
test[[1000]]
```

## need a way to test if a settlement has become completely depopulated and allow it to repopulate
possible a reason to have the environental table be separate and repeatedly joined to the population table or something

```{r}
test_pop %>% 
  unnest() %>% 
  mutate(max_land = max_cultivable_land(laborers, farming_labor, area * arable * 100, type = 'unlimited'),
         land_need = pmin(max_land, calc_land_req(occupants, yield_memory)),# land in hectares to support the household, but no more than the laborer can work
         new_land = if_else(land_need > land, land_need - land, 0)) %>%
  group_by(settlement) %>%
  mutate(available_land = area * arable * 100 - sum(land),
         total_land_need = sum(new_land)) %>%
  ungroup %>%
  mutate(land = if_else(total_land_need > available_land, 
                        land + new_land / total_land_need * available_land, 
                        land + new_land)) %>%
  select(-c(land_need, max_land, new_land, total_land_need, available_land))
```

```{r}
plot(max_cultivable_land(5:10, 1, 100))
```


```{r}

```

