---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = TRUE)
```

testing
```{r}
# libraries to help with this particular analysis
library(ggplot2)
library(ggridges)
library(ggraph)
library(profvis)

# libraries needed for the package
devtools::load_all()
library(sf)
library(dplyr)
library(purrr)
library(furrr)
library(forcats)
library(tidygraph)

# lets use the development version of tidyr, because fill() is significantly faster in it
#devtools::install_github("tidyverse/tidyr")
library(tidyr)
```
set seed for reproducability
```{r}
set.seed(1000)
```


## Single population demography

First we'll create two test populations of ten people each, one with random ages and the other with only 25 year olds.

```{r}
test_pop1 <- create_individuals(10, random = FALSE)
```

Then run a 1,000 year simulation from each of the two initial populations.
```{r}
plan(multicore)
nsim <- 600

demographic_sim <- tibble(time = 0:nsim,
                          age = accumulate(1:nsim, ~population_dynamics(.x), .init = test_pop1),
                          population = map_dbl(age, length))
```

Look at the results.

```{r, echo = FALSE}
d1 <- demographic_sim %>%
  filter(time %in% c(0, 100, 200, 300, 400, 500)) %>%
  unnest %>%
  group_by(time) %>%
  mutate(median_age = median(age))
ggplot(d1, aes(age)) +
  geom_histogram(binwidth = 1, center = 0) +
  geom_vline(aes(xintercept = median_age), color = 'red', linetype = 2) + # find a way to get median age to vary with facet
  facet_wrap(~time, scales = 'free_y') +
  labs(title = paste('Evolution of the age distribution over', nsim, 'years'), subtitle = 'Century snapshots') +
  theme_bw()

ggsave('age_distribution.png', height = 4, width = 6)
```

Now we can look at a food-limited population.

```{r}
demographic_sim2  <- tibble(food_ratio = seq(0.1, 1, by = 0.05)) %>%
  mutate(sim = future_map(food_ratio, function(x) accumulate(1:nsim, ~population_dynamics(.x, food_ratio_c = x), .init = test_pop1)),
         sim = map(sim, ~tibble(time = 0:nsim,
                          age = .,
                          population = map_dbl(age, length))))
```

```{r}
demographic_sim2 %>%
  unnest %>%
  ggplot(aes(time, population, group = food_ratio, color = food_ratio)) +
  geom_line(alpha = .5) +
  scale_y_continuous(trans = 'log') +
  scale_color_viridis_c() +
  theme_bw()
```


```{r, eval = FALSE}
profvis(reduce(1:nsim, ~population_dynamics(.x, food_ratio = 1), .init = test_pop1))
```

# Single settlement dynamics

```{r}
test_pop2 <- create_households(5)
farming_sim <- accumulate(1:1000, ~household_dynamics(.x, rainfall_c = .7, cultivable_area_c = 40) %>% population_dynamics, .init = test_pop2)
```


```{r, warning = FALSE}
farming_sim %>%
  bind_rows(.id = 'time') %>%
  group_by(time) %>%
  summarise(population = sum(occupants)) %>%
  ggplot(aes(as.numeric(time), population)) +
  geom_line() +
  theme_bw()
```
```{r, eval = FALSE}
profvis(reduce(1:nsim, ~household_dynamics(.x, rainfall_c = 0.7, cultivable_area_c = 30) %>% population_dynamics, .init = test_pop2))
```

Look how the population growth rate changes over several 50 year time steps
```{r, warning = FALSE}
farming_sim %>%
    bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time)) %>%
  group_by(time) %>%
  summarise(population = sum(occupants)) %>%
  mutate(old_pop = lag(population),
         rate = population / old_pop - 1,
         time_step = c(0, rep(1:10, each = 60))) %>%
  filter(time_step != 0) %>%
  ggplot(aes(rate, as.factor(time_step))) +
  geom_density_ridges() + 
  scale_y_discrete(labels = seq(0, 600, by = 50)) +
  geom_vline(xintercept = 0, color ='red', linetype = 2) +
  labs(x = 'Population growth rate', y = 'Year') +
  theme_bw()
```

```{r}
# next step is to tweak micro behavior so this is asymptotic rather than piecewise
farming_sim %>%
  bind_rows(.id = 'time') %>%
  group_by(time) %>%
  summarise(population = sum(occupants), land = sum(land)) %>%
  ggplot(aes(population, land)) +
  geom_line(alpha = .2) +
  geom_point(aes(color = as.numeric(time))) +
  scale_color_viridis_c() +
  theme_classic() +
  labs(title = 'Coevolution of population and cultivated area')
```


```{r, eval = FALSE}
profvis(accumulate(1:100, ~household_dynamics(.x) %>% population_dynamics, .init = test_pop3))
```

Let's repeat this 50 times.
```{r, cache = TRUE}
plan(multicore)
farming_sim2 <- 1:8 %>%
  future_map(~ accumulate(1:nsim, ~household_dynamics(.x, rainfall_c = 0.7, cultivable_area_c = 10) %>% population_dynamics, .init = test_pop2), .progress = TRUE) %>%
  map_dfr(~suppressWarnings(bind_rows(., .id = 'time')), .id = 'rep') %>%
  mutate(time = as.numeric(time)) 
```

```{r}
farming_sim2 %>%
  group_by(rep, time) %>%
  summarise(population = sum(occupants)) %>%
  ggplot(aes(time, population)) +
  geom_line(aes(group = rep), alpha = 0.3) +
  geom_smooth() +
  theme_bw()
```

We can see from above that, in spite of the stochasticity, we converging on logistic growth. The inflection point above is at about year 250. We can replicate this using the discrete time logistic growth model with a carrying capacity of 150 and an intrinsic growth rate of 0.02, the typical value estimated for agrarian societies. Comparing our model's growth curve to the logistic equation shows our model has slightly slower growth, likely due to the extra stochasticity introduced by having discrete households rather than a single well-mixed population. In fact, a growth rate of ~0.017 fits better. But in the end, we can see logistic growth predicts a smooth transition to the carrying capacity, where in our model we have a sharper demographic transition. This is characteristic of food limited demography.

```{r}
logistic_growth <- accumulate(1:nsim, ~.x * (1 + 0.0176 * (1 - (.x / 1250))), .init = 9) %>%
  tibble(time = 0:nsim, population = .)

farming_sim2 %>%
  group_by(rep, time) %>%
  summarise(population = sum(occupants)) %>%
  ggplot(aes(time, population)) +
  #geom_line(aes(group = rep), alpha = 0.3) +
  stat_smooth(aes(group = rep, color = as.numeric(rep)), method = "gam", formula = y ~ s(x, bs = "cs"), geom = 'line', se = FALSE, alpha = .7, size = 1.2) +
  scale_color_viridis_c() +
  geom_line(data = logistic_growth, size = 1.2, color = 'red') +
  theme_classic()
```

```{r}
farming_sim2 %>%
  filter(time == nsim + 1) %>%
  group_by(rep) %>%
  summarise(population = sum(occupants)) %>%
  ggplot(aes(population)) +
  geom_histogram(binwidth = 50) +
  theme_bw()
```

```{r}
farming_sim2 %>%
  group_by(time, rep) %>%
  summarise(population = sum(occupants)) %>%
  filter(time %in% seq(0, nsim, by = nsim/10)) %>%
  ggplot(aes(population, as.ordered(time))) +
  geom_density_ridges() +
  theme_ridges()

farming_sim2 %>%
  group_by(time, rep) %>%
  summarise(population = sum(occupants)) %>%
   mutate(old_pop = lag(population),
         rate = population / old_pop - 1) %>%
  filter(time %in% seq(1, 600, by = 50)) %>%
  ggplot(aes(rate, as.factor(time))) +
  geom_density_ridges() + 
  scale_y_discrete(labels = seq(0, 600, by = 50)) +
  geom_vline(xintercept = 0, color ='red', linetype = 2) +
  labs(x = 'Population growth rate', y = 'Year') +
  theme_bw()


```

```{r}
plan(multicore)
nsim <- 700
farming_sim3 <- read_sf('../NA_env.shp') %>%
  select(rainfall = prcpttn,
         cultivable_area = cltvbl_) %>%
  filter(!is.na(rainfall) & !is.na(cultivable_area)) %>%
  mutate(sim = future_map2(rainfall, cultivable_area, function(x, y) (reduce(1:nsim, ~household_dynamics(.x, rainfall_c = x, cultivable_area_c = y) %>% population_dynamics, .init = test_pop2) %>% summarise(population = sum(occupants))), .progress = TRUE))


  map_dfr(~suppressWarnings(bind_rows(., .id = 'time')), .id = 'rep') %>%
  mutate(time = as.numeric(time)) 
```


```{r}
farming_sim3 <- expand_grid(rainfall = seq(0.1, 1.5, by = 0.1), 
       cultivable_area = seq(1, 41, by = 5)) %>%
  bind_rows(., ., ., .) %>%
  mutate(sim = future_map2(rainfall, cultivable_area, function(x, y) (reduce(1:nsim, ~household_dynamics(.x, rainfall_c = x, cultivable_area_c = y) %>% population_dynamics, .init = test_pop2) %>% summarise(population = sum(occupants))), .progress = TRUE))
  map_dfr(~suppressWarnings(bind_rows(., .id = 'time')), .id = 'rep') %>%
  mutate(time = as.numeric(time)) 
```

```{r}
gam_Dat <- farming_sim3 %>% bind_rows %>% mutate(population = map_dbl(sim, ~.$population))

library(mgcv)
ggplot(gam_Dat, aes(cultivable_area, population)) +
  geom_point()
m1 <- gam(population ~ s(rainfall, k = 5) + s(cultivable_area, k = 5), data = gam_Dat, method = 'REML')
m1 <- gam(population ~ te(rainfall, cultivable_area), data = gam_Dat, method = 'REML')

plot(m1, scheme = 2)
summary(m1)


plot(seq(.3, 1.2, .1), calc_climatic_yield(seq(.3, 1.2, .1)))
```


# Settlement dynamics
```{r}
world <- create_world()
ggplot(world) +
  geom_sf(aes(fill = rainfall), color = 'white') +
  coord_sf(datum = NA) +
  scale_fill_viridis_c() +
  theme_void()
```
  
```{r}
settlements <- create_settlements(world)

settlements %E>%
  mutate(route = near(distance, min(distance))) %>%
  filter(route == TRUE) %>%
ggraph() +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_fixed() +
  theme_void()
```

```{r, eval = FALSE}
plan(multicore)
profvis((reduce(1:5, ~settlement_dynamics(.x), .init = filter(activate(settlements, 'edges'), distance < 40))))
```

```{r, cache = TRUE}
system.time(suppressWarnings(reduce(1:100, ~settlement_dynamics(.x), .init = filter(activate(settlements, 'edges'), distance < 40))))
test_grid <- suppressWarnings(accumulate(1:300, ~settlement_dynamics(.x), .init = filter(activate(settlements, 'edges'), distance < 40)))

memory.profile()
```

so right now, attractiveness is size based. that means that once a settlement hits 0, no one will ever want to move there right? this is why at equilibrium the largest sites are only ~150 people. So we need two sets of migrations, local and larger. maybe the spatial interaction model with full pariwise connections is a big migration, and something else for the neighboring 6 cells. perhaps that move can be land based or something else, maybe the fussion fission group joining thing. hmmmm
```{r}
test_grid %>%
  .[[501]] %E>%
   filter(near(distance, min(distance))) %>%
  ggraph +
  geom_edge_link() +
  geom_node_point(aes(size = population)) +
  coord_equal() +
  theme_graph()

test_grid %>%
  .[[501]] %>%
  as_tibble %>%
  st_as_sf %>%
  ggplot() +
  geom_sf(aes(fill = population), color = 'white') +
  coord_sf(datum = NA) +
  scale_fill_viridis_c()
```

```{r}
test_grid %>%
  map_dfr(as_tibble, .id = 'time') %>%
  ggplot(aes(as.numeric(time), log(population), group = settlement, color = settlement)) +
  geom_smooth(alpha = .5) +
  theme_classic()

test_grid %>%
  map_dfr(as_tibble, .id = 'time') %>%
  ggplot(aes(as.numeric(time), population, group = settlement, color = settlement)) +
  geom_line(alpha = .5) +
  theme_classic()

test_grid %>%
  map_dfr(as_tibble, .id = 'time') %>%
  mutate(land = map_dbl(households, ~sum(.$land))) %>%
  ggplot(aes(as.numeric(time), land, group = settlement, color = settlement)) +
  geom_smooth(alpha = .5) +
  theme_classic()
```


AT some point it'd be nice to include like 10-20 percent of your food ratio, etc, as a function of the flows from other places. or maybe the flows from other places make up a pool of resources at the settlement level that the households divide amongst themselves



sublinear scaling of area to population in a settlement
plot population vs urban area. so the maximum settlement we can hold in 1km has 25,000 people. beyond that we need more than one 1km tile
```{r}
tibble(population = seq(1,100000, 1000),
       area = 0.175 * population ^ 0.634) %>%
  ggplot(aes(population, area)) +
  geom_line() 
```
```{r}
vegetation <- tibble(stage = 0:50)
vegetation_to_biomass(vegetation)

vegetation %>%
  stage_to_biomass() %>%
ggplot(aes(stage, biomass)) +
  geom_line() +
  labs(title = 'Vegetation to biomass conversion', x = 'Vegetation succession stage', y = 'Biomass (kg/m2)') +
  theme_minimal()
```

sublinear scaling of firewood
```{r}
wood_req <- 1600 # yearly firewood requirement (kg) per person
max_wood_gather_intensity <- 0.08 * 1e6 # maximum wood gathering intensity in kg/m2, converted to to kg/km2 ### should tweak to account for grid cellsbeing less than 1km2

#this plot says that a population of less than 130 people can get their wood requirmenets from a fully vegetated 1km2 grid cell at the gathering intensity rate of 0.08 kg/m2. Above that population, right now people just extract more wood than they should ethnogrpahically. ideally at this threshold they would start gathering wood from naighboring patches.
qplot(1:200, (wood_req * (1:200) ^ 0.8), geom= 'line') +
  geom_hline(yintercept = max_wood_gather_intensity)
```







```{r}
ariadne <- function(x){
  (1 + x ^ 4)^-1
}
tibble(distance = 1:100, 
       interaction = exp(-.1 * distance)) %>%
  ggplot(aes(distance, interaction)) +
  scale_y_continuous(limits = c(0,1)) +
  geom_line()
```

This is where the default demographic data that comes with the package gets made. Need to improve.
```{r, eval = FALSE}
foodlim <- readr::read_csv('~/gdrive/Foodlim_R_code/demog_vectors.csv')

life_table <- tibble(
  age = 0:119,
  fertility_rate = c(rep(0, 12), 0.022, 0.022, 0.022, rep(c(0.232, 0.343, 0.367, 0.293, 0.218, 0.216, 0.134), each = 5), rep(0, 70)) ,
  survival_rate = (1 - c(0.381, rep(0.063, 4), rep(c(0.013, 0.010, 0.013, 0.016, 0.018, 0.020, 0.022, 0.024, 0.025, 0.033, 0.042, 0.062, 
                                                 0.084, 0.122, 0.175, 0.254, 0.376, 0.552, 0.816, 1, 1, 1, 1), each = 5))), # convert mortality rate to survival rate
  survival_shape = foodlim$mortparms,
  relative_cal_need = foodlim$rho
)
usethis::use_data(life_table, internal =TRUE, overwrite = TRUE)
usethis::use_testthat()

plot(fertility_table)
```
